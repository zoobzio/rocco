---
title: Authentication Patterns
description: JWT, API keys, and session authentication implementations
author: zoobzio
published: 2025-12-16
updated: 2025-12-16
tags:
  - Cookbook
  - Authentication
  - JWT
  - Security
---

# Authentication Cookbook

Implementation patterns for common authentication scenarios.

## JWT Authentication

### Identity Implementation

```go
type JWTIdentity struct {
    userID   string
    tenantID string
    email    string
    scopes   []string
    roles    []string
}

func (i *JWTIdentity) ID() string            { return i.userID }
func (i *JWTIdentity) TenantID() string      { return i.tenantID }
func (i *JWTIdentity) Stats() map[string]int { return nil }

func (i *JWTIdentity) HasScope(scope string) bool {
    for _, s := range i.scopes {
        if s == scope {
            return true
        }
    }
    return false
}

func (i *JWTIdentity) HasRole(role string) bool {
    for _, r := range i.roles {
        if r == role {
            return true
        }
    }
    return false
}

// Extra methods for application use
func (i *JWTIdentity) Email() string { return i.email }
```

### Identity Extractor

```go
import (
    "context"
    "errors"
    "net/http"
    "strings"

    "github.com/golang-jwt/jwt/v5"
    "github.com/zoobzio/rocco"
)

var jwtSecret = []byte(os.Getenv("JWT_SECRET"))

func extractJWTIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    // Get Authorization header
    auth := r.Header.Get("Authorization")
    if auth == "" {
        return nil, errors.New("missing authorization header")
    }

    // Validate Bearer format
    if !strings.HasPrefix(auth, "Bearer ") {
        return nil, errors.New("invalid authorization format")
    }

    tokenString := strings.TrimPrefix(auth, "Bearer ")

    // Parse and validate token
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        // Validate signing method
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, errors.New("invalid signing method")
        }
        return jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    claims, ok := token.Claims.(jwt.MapClaims)
    if !ok || !token.Valid {
        return nil, errors.New("invalid token")
    }

    // Extract claims
    return &JWTIdentity{
        userID:   claims["sub"].(string),
        tenantID: getStringClaim(claims, "tenant_id"),
        email:    getStringClaim(claims, "email"),
        scopes:   getStringSliceClaim(claims, "scope"),
        roles:    getStringSliceClaim(claims, "roles"),
    }, nil
}

func getStringClaim(claims jwt.MapClaims, key string) string {
    if v, ok := claims[key].(string); ok {
        return v
    }
    return ""
}

func getStringSliceClaim(claims jwt.MapClaims, key string) []string {
    switch v := claims[key].(type) {
    case []interface{}:
        result := make([]string, len(v))
        for i, item := range v {
            result[i] = item.(string)
        }
        return result
    case string:
        return strings.Split(v, " ")
    }
    return nil
}
```

### Login Handler

```go
type LoginInput struct {
    Email    string `json:"email" validate:"required,email"`
    Password string `json:"password" validate:"required,min=8"`
}

type LoginOutput struct {
    Token     string `json:"token"`
    ExpiresAt int64  `json:"expires_at"`
}

var loginHandler = rocco.NewHandler[LoginInput, LoginOutput](
    "login",
    "POST",
    "/auth/login",
    func(req *rocco.Request[LoginInput]) (LoginOutput, error) {
        // Verify credentials
        user, err := db.GetUserByEmail(req.Body.Email)
        if err != nil {
            return LoginOutput{}, rocco.ErrUnauthorized.WithMessage("invalid credentials")
        }

        if !verifyPassword(req.Body.Password, user.PasswordHash) {
            return LoginOutput{}, rocco.ErrUnauthorized.WithMessage("invalid credentials")
        }

        // Generate token
        expiresAt := time.Now().Add(24 * time.Hour)
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
            "sub":       user.ID,
            "tenant_id": user.TenantID,
            "email":     user.Email,
            "scope":     strings.Join(user.Scopes, " "),
            "roles":     user.Roles,
            "exp":       expiresAt.Unix(),
            "iat":       time.Now().Unix(),
        })

        tokenString, err := token.SignedString(jwtSecret)
        if err != nil {
            return LoginOutput{}, rocco.ErrInternalServer.WithCause(err)
        }

        return LoginOutput{
            Token:     tokenString,
            ExpiresAt: expiresAt.Unix(),
        }, nil
    },
).
    WithSummary("User login").
    WithTags("auth").
    WithErrors(rocco.ErrUnauthorized)
```

### Setup

```go
engine := rocco.NewEngine("localhost", 8080, extractJWTIdentity)

// Public endpoints
engine.WithHandlers(loginHandler)

// Protected endpoints
engine.WithHandlers(
    rocco.NewHandler[rocco.NoBody, User](
        "get-profile",
        "GET",
        "/profile",
        getProfile,
    ).WithAuthentication(),
)
```

## API Key Authentication

### Identity Implementation

```go
type APIKeyIdentity struct {
    keyID    string
    tenantID string
    name     string
    scopes   []string
}

func (i *APIKeyIdentity) ID() string            { return i.keyID }
func (i *APIKeyIdentity) TenantID() string      { return i.tenantID }
func (i *APIKeyIdentity) Stats() map[string]int { return nil }

func (i *APIKeyIdentity) HasScope(scope string) bool {
    for _, s := range i.scopes {
        if s == scope {
            return true
        }
    }
    return false
}

func (i *APIKeyIdentity) HasRole(string) bool { return false }
```

### Identity Extractor

```go
func extractAPIKeyIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    // Check header
    apiKey := r.Header.Get("X-API-Key")
    if apiKey == "" {
        // Fall back to query param (for webhooks)
        apiKey = r.URL.Query().Get("api_key")
    }

    if apiKey == "" {
        return nil, errors.New("missing API key")
    }

    // Validate key format
    if !strings.HasPrefix(apiKey, "sk_") {
        return nil, errors.New("invalid API key format")
    }

    // Look up key (use constant-time comparison in production)
    keyInfo, err := db.GetAPIKey(hashAPIKey(apiKey))
    if err != nil {
        return nil, errors.New("invalid API key")
    }

    // Check if key is active
    if !keyInfo.Active {
        return nil, errors.New("API key disabled")
    }

    // Check expiration
    if keyInfo.ExpiresAt != nil && keyInfo.ExpiresAt.Before(time.Now()) {
        return nil, errors.New("API key expired")
    }

    return &APIKeyIdentity{
        keyID:    keyInfo.ID,
        tenantID: keyInfo.TenantID,
        name:     keyInfo.Name,
        scopes:   keyInfo.Scopes,
    }, nil
}
```

### API Key Management

```go
type CreateAPIKeyInput struct {
    Name   string   `json:"name" validate:"required,min=1,max=100"`
    Scopes []string `json:"scopes" validate:"required,min=1"`
}

type APIKeyOutput struct {
    ID        string    `json:"id"`
    Key       string    `json:"key,omitempty"` // Only returned on creation
    Name      string    `json:"name"`
    Scopes    []string  `json:"scopes"`
    CreatedAt time.Time `json:"created_at"`
}

var createAPIKey = rocco.NewHandler[CreateAPIKeyInput, APIKeyOutput](
    "create-api-key",
    "POST",
    "/api-keys",
    func(req *rocco.Request[CreateAPIKeyInput]) (APIKeyOutput, error) {
        // Generate key
        key := "sk_" + generateSecureRandom(32)
        keyHash := hashAPIKey(key)

        keyInfo := &APIKey{
            ID:        generateID(),
            KeyHash:   keyHash,
            TenantID:  req.Identity.TenantID(),
            Name:      req.Body.Name,
            Scopes:    req.Body.Scopes,
            CreatedAt: time.Now(),
        }

        if err := db.CreateAPIKey(keyInfo); err != nil {
            return APIKeyOutput{}, rocco.ErrInternalServer.WithCause(err)
        }

        return APIKeyOutput{
            ID:        keyInfo.ID,
            Key:       key, // Only returned once!
            Name:      keyInfo.Name,
            Scopes:    keyInfo.Scopes,
            CreatedAt: keyInfo.CreatedAt,
        }, nil
    },
).
    WithAuthentication().
    WithScopes("api-keys:write").
    WithSuccessStatus(201)
```

## Session Authentication

### Identity Implementation

```go
type SessionIdentity struct {
    sessionID string
    userID    string
    tenantID  string
    scopes    []string
    roles     []string
    stats     map[string]int
}

// Implement rocco.Identity interface...
```

### Identity Extractor

```go
func extractSessionIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    // Get session cookie
    cookie, err := r.Cookie("session_id")
    if err != nil {
        return nil, errors.New("no session")
    }

    // Look up session
    session, err := sessionStore.Get(cookie.Value)
    if err != nil {
        return nil, errors.New("invalid session")
    }

    // Check expiration
    if session.ExpiresAt.Before(time.Now()) {
        return nil, errors.New("session expired")
    }

    // Get user
    user, err := db.GetUser(session.UserID)
    if err != nil {
        return nil, errors.New("user not found")
    }

    return &SessionIdentity{
        sessionID: session.ID,
        userID:    user.ID,
        tenantID:  user.TenantID,
        scopes:    user.Scopes,
        roles:     user.Roles,
        stats:     getUserStats(user.ID),
    }, nil
}
```

## Multi-Auth Support

Support multiple authentication methods:

```go
func extractIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    // Try JWT first
    if auth := r.Header.Get("Authorization"); strings.HasPrefix(auth, "Bearer ") {
        return extractJWTIdentity(ctx, r)
    }

    // Try API key
    if apiKey := r.Header.Get("X-API-Key"); apiKey != "" {
        return extractAPIKeyIdentity(ctx, r)
    }

    // Try session cookie
    if _, err := r.Cookie("session_id"); err == nil {
        return extractSessionIdentity(ctx, r)
    }

    return nil, errors.New("no authentication provided")
}
```

## Usage Limits with Stats

```go
type PlanBasedIdentity struct {
    userID   string
    tenantID string
    plan     string // "free", "pro", "enterprise"
    scopes   []string
    roles    []string
    stats    map[string]int
}

func (i *PlanBasedIdentity) Stats() map[string]int {
    // Return current usage stats
    return i.stats
}

// Handler with usage limits
var createResource = rocco.NewHandler[Input, Output](
    "create-resource",
    "POST",
    "/resources",
    createResourceHandler,
).
    WithAuthentication().
    WithUsageLimit("resources_created_today", func(id rocco.Identity) int {
        // Dynamic limits based on plan
        planID := id.(*PlanBasedIdentity).plan
        switch planID {
        case "enterprise":
            return 10000
        case "pro":
            return 1000
        default:
            return 100
        }
    })
```

## Security Best Practices

### 1. Use HTTPS

Always use HTTPS in production. Rocco doesn't handle TLS - use a reverse proxy.

### 2. Short Token Lifetimes

```go
// Access tokens: short lived
accessExpiry := time.Now().Add(15 * time.Minute)

// Refresh tokens: longer, but rotated
refreshExpiry := time.Now().Add(7 * 24 * time.Hour)
```

### 3. Log Security Events

```go
capitan.Hook(rocco.AuthenticationFailed, func(ctx context.Context, e *capitan.Event) {
    path, _ := rocco.PathKey.From(e)
    err, _ := rocco.ErrorKey.From(e)
    securityLog.Warn("auth_failed", "path", path, "error", err)
})
```

### 4. Rate Limit Auth Endpoints

```go
loginHandler.WithMiddleware(rateLimiter(5, time.Minute))
```

### 5. Hash API Keys

```go
func hashAPIKey(key string) string {
    hash := sha256.Sum256([]byte(key))
    return hex.EncodeToString(hash[:])
}
```

## See Also

- [Authentication Guide](../3.guides/3.authentication.md) - Detailed auth patterns
- [Best Practices](../3.guides/5.best-practices.md) - Security recommendations
- [Events Reference](../5.reference/3.events.md) - Auth events
