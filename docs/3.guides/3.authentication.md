---
title: Authentication & Authorization
description: Identity extraction, scopes, roles, and usage limits
author: zoobzio
published: 2025-12-16
updated: 2025-12-16
tags:
  - Authentication
  - Authorization
  - Identity
  - Security
---

# Authentication & Authorization Guide

Rocco provides built-in support for identity extraction, scope-based authorization, role-based access control, and usage limits.

## Identity Interface

Implement the `Identity` interface to represent authenticated users:

```go
type Identity interface {
    ID() string              // Unique user/service identifier
    TenantID() string        // Tenant/organization ID (multi-tenancy)
    HasScope(string) bool    // Check if identity has scope
    HasRole(string) bool     // Check if identity has role
    Stats() map[string]int   // Usage statistics for rate limiting
}
```

### Example Implementation

```go
type UserIdentity struct {
    id       string
    tenantID string
    scopes   []string
    roles    []string
    stats    map[string]int
}

func (u *UserIdentity) ID() string            { return u.id }
func (u *UserIdentity) TenantID() string      { return u.tenantID }
func (u *UserIdentity) Stats() map[string]int { return u.stats }

func (u *UserIdentity) HasScope(scope string) bool {
    for _, s := range u.scopes {
        if s == scope {
            return true
        }
    }
    return false
}

func (u *UserIdentity) HasRole(role string) bool {
    for _, r := range u.roles {
        if r == role {
            return true
        }
    }
    return false
}
```

## Identity Extraction

Provide an identity extractor when creating the engine:

```go
engine := rocco.NewEngine("localhost", 8080, extractIdentity)

func extractIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    // Get token from header
    token := r.Header.Get("Authorization")
    if token == "" {
        return nil, errors.New("missing authorization header")
    }

    // Validate token (JWT, session lookup, API key, etc.)
    claims, err := validateToken(strings.TrimPrefix(token, "Bearer "))
    if err != nil {
        return nil, err
    }

    // Return identity
    return &UserIdentity{
        id:       claims.Subject,
        tenantID: claims.TenantID,
        scopes:   claims.Scopes,
        roles:    claims.Roles,
        stats:    fetchStats(claims.Subject),
    }, nil
}
```

### JWT Example

```go
func extractIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    auth := r.Header.Get("Authorization")
    if !strings.HasPrefix(auth, "Bearer ") {
        return nil, errors.New("invalid authorization header")
    }

    tokenString := strings.TrimPrefix(auth, "Bearer ")

    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        return []byte(secretKey), nil
    })
    if err != nil {
        return nil, err
    }

    claims, ok := token.Claims.(jwt.MapClaims)
    if !ok || !token.Valid {
        return nil, errors.New("invalid token")
    }

    return &UserIdentity{
        id:       claims["sub"].(string),
        tenantID: claims["tenant_id"].(string),
        scopes:   parseScopes(claims["scope"]),
        roles:    parseRoles(claims["roles"]),
    }, nil
}
```

### API Key Example

```go
func extractIdentity(ctx context.Context, r *http.Request) (rocco.Identity, error) {
    apiKey := r.Header.Get("X-API-Key")
    if apiKey == "" {
        return nil, errors.New("missing API key")
    }

    // Look up API key in database
    keyInfo, err := db.GetAPIKey(apiKey)
    if err != nil {
        return nil, errors.New("invalid API key")
    }

    return &ServiceIdentity{
        id:       keyInfo.ServiceID,
        tenantID: keyInfo.TenantID,
        scopes:   keyInfo.Scopes,
    }, nil
}
```

## Requiring Authentication

Mark handlers as requiring authentication:

```go
handler := rocco.NewHandler[rocco.NoBody, User](
    "get-profile",
    "GET",
    "/profile",
    func(req *rocco.Request[rocco.NoBody]) (User, error) {
        // req.Identity is guaranteed to be non-nil
        return getUser(req.Identity.ID())
    },
).WithAuthentication()
```

Unauthenticated requests receive 401 Unauthorized.

## Scope-Based Authorization

Require specific scopes:

```go
// Single scope required
handler.WithScopes("users:read")

// Any of these scopes (OR logic)
handler.WithScopes("users:read", "users:admin")

// Multiple scope groups (AND logic)
handler.WithScopes("users:read").WithScopes("verified")
// Requires (users:read OR users:admin) AND verified
```

### Scope Patterns

Common scope naming conventions:

```go
// Resource-based
handler.WithScopes("users:read")
handler.WithScopes("users:write")
handler.WithScopes("orders:read", "orders:write")

// Action-based
handler.WithScopes("read")
handler.WithScopes("write")
handler.WithScopes("delete")

// Feature-based
handler.WithScopes("analytics")
handler.WithScopes("reports")
handler.WithScopes("admin")
```

## Role-Based Access Control

Require specific roles:

```go
// Single role required
handler.WithRoles("admin")

// Any of these roles (OR logic)
handler.WithRoles("admin", "moderator")

// Multiple role groups (AND logic)
handler.WithRoles("admin").WithRoles("verified")
// Requires (admin OR moderator) AND verified
```

### Combining Scopes and Roles

```go
handler := rocco.NewHandler[rocco.NoBody, AdminData](
    "admin-dashboard",
    "GET",
    "/admin/dashboard",
    getAdminDashboard,
).
    WithScopes("admin:read").   // Must have admin:read scope
    WithRoles("admin", "super") // Must have admin OR super role
```

## Usage Limits

Rate limit based on identity statistics:

```go
handler := rocco.NewHandler[Input, Output](
    "create-resource",
    "POST",
    "/resources",
    createResource,
).WithUsageLimit("api_calls_today", func(id rocco.Identity) int {
    // Return limit based on identity
    if id.HasRole("premium") {
        return 10000
    }
    return 100
})
```

The handler checks `identity.Stats()["api_calls_today"]` against the limit. If exceeded, returns 429 Too Many Requests.

### Multiple Limits

```go
handler.
    WithUsageLimit("api_calls_today", dailyLimit).
    WithUsageLimit("storage_mb", storageLimit).
    WithUsageLimit("concurrent_jobs", concurrencyLimit)
```

## Accessing Identity in Handlers

```go
func(req *rocco.Request[Input]) (Output, error) {
    // Get identity (nil if handler doesn't require auth)
    identity := req.Identity

    // Check auth status
    if identity == nil {
        // Handler allows anonymous access
    }

    // Access identity data
    userID := identity.ID()
    tenantID := identity.TenantID()

    // Check permissions programmatically
    if identity.HasScope("admin:write") {
        // Admin logic
    }

    // Multi-tenancy: filter by tenant
    users, _ := db.FindUsers(tenantID)

    return Output{...}, nil
}
```

## NoIdentity Type

For handlers that don't require authentication, `req.Identity` is a `NoIdentity`:

```go
type NoIdentity struct{}

func (NoIdentity) ID() string            { return "" }
func (NoIdentity) TenantID() string      { return "" }
func (NoIdentity) HasScope(string) bool  { return false }
func (NoIdentity) HasRole(string) bool   { return false }
func (NoIdentity) Stats() map[string]int { return nil }
```

## Error Responses

| Scenario | Status | Error |
|----------|--------|-------|
| No/invalid identity | 401 | `ErrUnauthorized` |
| Missing required scope | 403 | `ErrForbidden` (message: "insufficient scope") |
| Missing required role | 403 | `ErrForbidden` (message: "insufficient role") |
| Usage limit exceeded | 429 | `ErrTooManyRequests` |

## Events

Authentication events are emitted via capitan:

| Event | Description |
|-------|-------------|
| `AuthenticationFailed` | Identity extraction failed |
| `AuthenticationSucceeded` | Identity extracted successfully |
| `AuthorizationScopeDenied` | Scope check failed |
| `AuthorizationRoleDenied` | Role check failed |
| `AuthorizationSucceeded` | Authorization passed |
| `RateLimitExceeded` | Usage limit exceeded |

## Best Practices

### 1. Use HTTPS in Production

Rocco doesn't handle TLS. Use a reverse proxy (nginx, Caddy) or cloud load balancer.

### 2. Validate Tokens Properly

```go
// Use constant-time comparison
// Set reasonable expiration times
// Validate issuer and audience
```

### 3. Implement Token Refresh

Don't rely on long-lived tokens. Implement refresh token flows.

### 4. Log Authentication Failures

```go
capitan.Hook(rocco.AuthenticationFailed, func(ctx context.Context, e *capitan.Event) {
    path, _ := rocco.PathKey.From(e)
    err, _ := rocco.ErrorKey.From(e)
    securityLog.Warn("auth failed", "path", path, "error", err)
})
```

### 5. Multi-Tenancy

Always filter data by tenant:

```go
func(req *rocco.Request[Input]) (Output, error) {
    tenantID := req.Identity.TenantID()

    // ALWAYS filter by tenant
    data, _ := db.Query("SELECT * FROM items WHERE tenant_id = ?", tenantID)

    return Output{...}, nil
}
```

## See Also

- [Best Practices](5.best-practices.md) - Security recommendations
- [Authentication Cookbook](../4.cookbook/2.authentication.md) - Implementation patterns
- [Events Reference](../5.reference/3.events.md) - Auth event details
